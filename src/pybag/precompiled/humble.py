"""Pre-compiled ROS2 message encoders/decoders for Humble.

This file is auto-generated by scripts/precompile_messages.py
DO NOT EDIT MANUALLY.
"""

from __future__ import annotations

import struct
from typing import TYPE_CHECKING, Any, Callable

if TYPE_CHECKING:
    from pybag.encoding import MessageDecoder, MessageEncoder

# Dataclass types dictionary will be populated at runtime
_dataclass_types: dict[str, type] = {}

# ==================== DECODER FUNCTIONS ====================

# Decoder for builtin_interfaces/msg/Duration
import struct
def decode_builtin_interfaces_msg_Duration(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Duration'](**_fields)

# Decoder for builtin_interfaces/msg/Time
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

# Decoder for std_msgs/msg/Bool
import struct
def decode_std_msgs_msg_Bool(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    _fields['data'] = struct.unpack(fmt_prefix + '?', _data.read(1))[0]
    return _dataclass_types['std_msgs_msg_Bool'](**_fields)

# Decoder for std_msgs/msg/Byte
import struct
def decode_std_msgs_msg_Byte(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['data'] = decoder.byte()
    return _dataclass_types['std_msgs_msg_Byte'](**_fields)

# Decoder for std_msgs/msg/ByteMultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_ByteMultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _fields['data'] = decoder.sequence('byte')
    return _dataclass_types['std_msgs_msg_ByteMultiArray'](**_fields)

# Decoder for std_msgs/msg/Char
import struct
def decode_std_msgs_msg_Char(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['data'] = decoder.char()
    return _dataclass_types['std_msgs_msg_Char'](**_fields)

# Decoder for std_msgs/msg/ColorRGBA
import struct
def decode_std_msgs_msg_ColorRGBA(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    r, g, b, a = struct.unpack(fmt_prefix + 'ffff', _data.read(16))
    _fields['r'] = r
    _fields['g'] = g
    _fields['b'] = b
    _fields['a'] = a
    return _dataclass_types['std_msgs_msg_ColorRGBA'](**_fields)

# Decoder for std_msgs/msg/Empty
import struct
def decode_std_msgs_msg_Empty(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    _fields['structure_needs_at_least_one_member'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    return _dataclass_types['std_msgs_msg_Empty'](**_fields)

# Decoder for std_msgs/msg/Float32
import struct
def decode_std_msgs_msg_Float32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['data'] = struct.unpack(fmt_prefix + 'f', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_Float32'](**_fields)

# Decoder for std_msgs/msg/Float32MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_Float32MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(4)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    return _dataclass_types['std_msgs_msg_Float32MultiArray'](**_fields)

# Decoder for std_msgs/msg/Float64
import struct
def decode_std_msgs_msg_Float64(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    _fields['data'] = struct.unpack(fmt_prefix + 'd', _data.read(8))[0]
    return _dataclass_types['std_msgs_msg_Float64'](**_fields)

# Decoder for std_msgs/msg/Float64MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_Float64MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(8)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'd' * _len, _data.read(8 * _len)))
    return _dataclass_types['std_msgs_msg_Float64MultiArray'](**_fields)

# Decoder for std_msgs/msg/Header
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

# Decoder for std_msgs/msg/Int16
import struct
def decode_std_msgs_msg_Int16(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(2)
    _fields['data'] = struct.unpack(fmt_prefix + 'h', _data.read(2))[0]
    return _dataclass_types['std_msgs_msg_Int16'](**_fields)

# Decoder for std_msgs/msg/Int16MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_Int16MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(2)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'h' * _len, _data.read(2 * _len)))
    return _dataclass_types['std_msgs_msg_Int16MultiArray'](**_fields)

# Decoder for std_msgs/msg/Int32
import struct
def decode_std_msgs_msg_Int32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['data'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_Int32'](**_fields)

# Decoder for std_msgs/msg/Int32MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_Int32MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(4)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'i' * _len, _data.read(4 * _len)))
    return _dataclass_types['std_msgs_msg_Int32MultiArray'](**_fields)

# Decoder for std_msgs/msg/Int64
import struct
def decode_std_msgs_msg_Int64(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    _fields['data'] = struct.unpack(fmt_prefix + 'q', _data.read(8))[0]
    return _dataclass_types['std_msgs_msg_Int64'](**_fields)

# Decoder for std_msgs/msg/Int64MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_Int64MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(8)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'q' * _len, _data.read(8 * _len)))
    return _dataclass_types['std_msgs_msg_Int64MultiArray'](**_fields)

# Decoder for std_msgs/msg/Int8
import struct
def decode_std_msgs_msg_Int8(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    _fields['data'] = struct.unpack(fmt_prefix + 'b', _data.read(1))[0]
    return _dataclass_types['std_msgs_msg_Int8'](**_fields)

# Decoder for std_msgs/msg/Int8MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_Int8MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(1)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'b' * _len, _data.read(1 * _len)))
    return _dataclass_types['std_msgs_msg_Int8MultiArray'](**_fields)

# Decoder for std_msgs/msg/MultiArrayDimension
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

# Decoder for std_msgs/msg/MultiArrayLayout
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

# Decoder for std_msgs/msg/String
import struct
def decode_std_msgs_msg_String(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['data'] = decoder.string()
    return _dataclass_types['std_msgs_msg_String'](**_fields)

# Decoder for std_msgs/msg/UInt16
import struct
def decode_std_msgs_msg_UInt16(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(2)
    _fields['data'] = struct.unpack(fmt_prefix + 'H', _data.read(2))[0]
    return _dataclass_types['std_msgs_msg_UInt16'](**_fields)

# Decoder for std_msgs/msg/UInt16MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_UInt16MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(2)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'H' * _len, _data.read(2 * _len)))
    return _dataclass_types['std_msgs_msg_UInt16MultiArray'](**_fields)

# Decoder for std_msgs/msg/UInt32
import struct
def decode_std_msgs_msg_UInt32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['data'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_UInt32'](**_fields)

# Decoder for std_msgs/msg/UInt32MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_UInt32MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(4)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'I' * _len, _data.read(4 * _len)))
    return _dataclass_types['std_msgs_msg_UInt32MultiArray'](**_fields)

# Decoder for std_msgs/msg/UInt64
import struct
def decode_std_msgs_msg_UInt64(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    _fields['data'] = struct.unpack(fmt_prefix + 'Q', _data.read(8))[0]
    return _dataclass_types['std_msgs_msg_UInt64'](**_fields)

# Decoder for std_msgs/msg/UInt64MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_UInt64MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(8)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'Q' * _len, _data.read(8 * _len)))
    return _dataclass_types['std_msgs_msg_UInt64MultiArray'](**_fields)

# Decoder for std_msgs/msg/UInt8
import struct
def decode_std_msgs_msg_UInt8(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    _fields['data'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    return _dataclass_types['std_msgs_msg_UInt8'](**_fields)

# Decoder for std_msgs/msg/UInt8MultiArray
import struct
def decode_std_msgs_msg_MultiArrayDimension(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['label'] = decoder.string()
    _data.align(4)
    size, stride = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['size'] = size
    _fields['stride'] = stride
    return _dataclass_types['std_msgs_msg_MultiArrayDimension'](**_fields)

def decode_std_msgs_msg_MultiArrayLayout(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['dim'] = [decode_std_msgs_msg_MultiArrayDimension(decoder) for _ in range(length)]
    _data.align(4)
    _fields['data_offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['std_msgs_msg_MultiArrayLayout'](**_fields)

def decode_std_msgs_msg_UInt8MultiArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['layout'] = decode_std_msgs_msg_MultiArrayLayout(decoder)
    _len = decoder.uint32()
    _data.align(1)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'B' * _len, _data.read(1 * _len)))
    return _dataclass_types['std_msgs_msg_UInt8MultiArray'](**_fields)

# Decoder for geometry_msgs/msg/Accel
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Accel(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Accel'](**_fields)

# Decoder for geometry_msgs/msg/AccelStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Accel(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Accel'](**_fields)

def decode_geometry_msgs_msg_AccelStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['accel'] = decode_geometry_msgs_msg_Accel(decoder)
    return _dataclass_types['geometry_msgs_msg_AccelStamped'](**_fields)

# Decoder for geometry_msgs/msg/AccelWithCovariance
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Accel(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Accel'](**_fields)

def decode_geometry_msgs_msg_AccelWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['accel'] = decode_geometry_msgs_msg_Accel(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_AccelWithCovariance'](**_fields)

# Decoder for geometry_msgs/msg/AccelWithCovarianceStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Accel(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Accel'](**_fields)

def decode_geometry_msgs_msg_AccelWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['accel'] = decode_geometry_msgs_msg_Accel(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_AccelWithCovariance'](**_fields)

def decode_geometry_msgs_msg_AccelWithCovarianceStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['accel'] = decode_geometry_msgs_msg_AccelWithCovariance(decoder)
    return _dataclass_types['geometry_msgs_msg_AccelWithCovarianceStamped'](**_fields)

# Decoder for geometry_msgs/msg/Inertia
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Inertia(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    _fields['m'] = struct.unpack(fmt_prefix + 'd', _data.read(8))[0]
    _fields['com'] = decode_geometry_msgs_msg_Vector3(decoder)
    _data.align(8)
    ixx, ixy, ixz, iyy, iyz, izz = struct.unpack(fmt_prefix + 'dddddd', _data.read(48))
    _fields['ixx'] = ixx
    _fields['ixy'] = ixy
    _fields['ixz'] = ixz
    _fields['iyy'] = iyy
    _fields['iyz'] = iyz
    _fields['izz'] = izz
    return _dataclass_types['geometry_msgs_msg_Inertia'](**_fields)

# Decoder for geometry_msgs/msg/InertiaStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Inertia(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    _fields['m'] = struct.unpack(fmt_prefix + 'd', _data.read(8))[0]
    _fields['com'] = decode_geometry_msgs_msg_Vector3(decoder)
    _data.align(8)
    ixx, ixy, ixz, iyy, iyz, izz = struct.unpack(fmt_prefix + 'dddddd', _data.read(48))
    _fields['ixx'] = ixx
    _fields['ixy'] = ixy
    _fields['ixz'] = ixz
    _fields['iyy'] = iyy
    _fields['iyz'] = iyz
    _fields['izz'] = izz
    return _dataclass_types['geometry_msgs_msg_Inertia'](**_fields)

def decode_geometry_msgs_msg_InertiaStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['inertia'] = decode_geometry_msgs_msg_Inertia(decoder)
    return _dataclass_types['geometry_msgs_msg_InertiaStamped'](**_fields)

# Decoder for geometry_msgs/msg/Point
import struct
def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

# Decoder for geometry_msgs/msg/Point32
import struct
def decode_geometry_msgs_msg_Point32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x, y, z = struct.unpack(fmt_prefix + 'fff', _data.read(12))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point32'](**_fields)

# Decoder for geometry_msgs/msg/PointStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_PointStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['point'] = decode_geometry_msgs_msg_Point(decoder)
    return _dataclass_types['geometry_msgs_msg_PointStamped'](**_fields)

# Decoder for geometry_msgs/msg/Polygon
import struct
def decode_geometry_msgs_msg_Point32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x, y, z = struct.unpack(fmt_prefix + 'fff', _data.read(12))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point32'](**_fields)

def decode_geometry_msgs_msg_Polygon(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['points'] = [decode_geometry_msgs_msg_Point32(decoder) for _ in range(length)]
    return _dataclass_types['geometry_msgs_msg_Polygon'](**_fields)

# Decoder for geometry_msgs/msg/PolygonInstance
import struct
def decode_geometry_msgs_msg_Point32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x, y, z = struct.unpack(fmt_prefix + 'fff', _data.read(12))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point32'](**_fields)

def decode_geometry_msgs_msg_Polygon(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['points'] = [decode_geometry_msgs_msg_Point32(decoder) for _ in range(length)]
    return _dataclass_types['geometry_msgs_msg_Polygon'](**_fields)

def decode_geometry_msgs_msg_PolygonInstance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['polygon'] = decode_geometry_msgs_msg_Polygon(decoder)
    _data.align(8)
    _fields['id'] = struct.unpack(fmt_prefix + 'q', _data.read(8))[0]
    return _dataclass_types['geometry_msgs_msg_PolygonInstance'](**_fields)

# Decoder for geometry_msgs/msg/PolygonInstanceStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x, y, z = struct.unpack(fmt_prefix + 'fff', _data.read(12))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point32'](**_fields)

def decode_geometry_msgs_msg_Polygon(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['points'] = [decode_geometry_msgs_msg_Point32(decoder) for _ in range(length)]
    return _dataclass_types['geometry_msgs_msg_Polygon'](**_fields)

def decode_geometry_msgs_msg_PolygonInstance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['polygon'] = decode_geometry_msgs_msg_Polygon(decoder)
    _data.align(8)
    _fields['id'] = struct.unpack(fmt_prefix + 'q', _data.read(8))[0]
    return _dataclass_types['geometry_msgs_msg_PolygonInstance'](**_fields)

def decode_geometry_msgs_msg_PolygonInstanceStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['polygon'] = decode_geometry_msgs_msg_PolygonInstance(decoder)
    return _dataclass_types['geometry_msgs_msg_PolygonInstanceStamped'](**_fields)

# Decoder for geometry_msgs/msg/PolygonStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x, y, z = struct.unpack(fmt_prefix + 'fff', _data.read(12))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point32'](**_fields)

def decode_geometry_msgs_msg_Polygon(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['points'] = [decode_geometry_msgs_msg_Point32(decoder) for _ in range(length)]
    return _dataclass_types['geometry_msgs_msg_Polygon'](**_fields)

def decode_geometry_msgs_msg_PolygonStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['polygon'] = decode_geometry_msgs_msg_Polygon(decoder)
    return _dataclass_types['geometry_msgs_msg_PolygonStamped'](**_fields)

# Decoder for geometry_msgs/msg/Pose
import struct
def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

# Decoder for geometry_msgs/msg/Pose2D
import struct
def decode_geometry_msgs_msg_Pose2D(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, theta = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['theta'] = theta
    return _dataclass_types['geometry_msgs_msg_Pose2D'](**_fields)

# Decoder for geometry_msgs/msg/PoseArray
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    length = decoder.uint32()
    _fields['poses'] = [decode_geometry_msgs_msg_Pose(decoder) for _ in range(length)]
    return _dataclass_types['geometry_msgs_msg_PoseArray'](**_fields)

# Decoder for geometry_msgs/msg/PoseStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['pose'] = decode_geometry_msgs_msg_Pose(decoder)
    return _dataclass_types['geometry_msgs_msg_PoseStamped'](**_fields)

# Decoder for geometry_msgs/msg/PoseWithCovariance
import struct
def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['pose'] = decode_geometry_msgs_msg_Pose(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_PoseWithCovariance'](**_fields)

# Decoder for geometry_msgs/msg/PoseWithCovarianceStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['pose'] = decode_geometry_msgs_msg_Pose(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_PoseWithCovariance'](**_fields)

def decode_geometry_msgs_msg_PoseWithCovarianceStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['pose'] = decode_geometry_msgs_msg_PoseWithCovariance(decoder)
    return _dataclass_types['geometry_msgs_msg_PoseWithCovarianceStamped'](**_fields)

# Decoder for geometry_msgs/msg/Quaternion
import struct
def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

# Decoder for geometry_msgs/msg/QuaternionStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_QuaternionStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['quaternion'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_QuaternionStamped'](**_fields)

# Decoder for geometry_msgs/msg/Transform
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Transform(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['translation'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['rotation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Transform'](**_fields)

# Decoder for geometry_msgs/msg/TransformStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Transform(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['translation'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['rotation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Transform'](**_fields)

def decode_geometry_msgs_msg_TransformStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['child_frame_id'] = decoder.string()
    _fields['transform'] = decode_geometry_msgs_msg_Transform(decoder)
    return _dataclass_types['geometry_msgs_msg_TransformStamped'](**_fields)

# Decoder for geometry_msgs/msg/Twist
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

# Decoder for geometry_msgs/msg/TwistStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

def decode_geometry_msgs_msg_TwistStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['twist'] = decode_geometry_msgs_msg_Twist(decoder)
    return _dataclass_types['geometry_msgs_msg_TwistStamped'](**_fields)

# Decoder for geometry_msgs/msg/TwistWithCovariance
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

def decode_geometry_msgs_msg_TwistWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['twist'] = decode_geometry_msgs_msg_Twist(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_TwistWithCovariance'](**_fields)

# Decoder for geometry_msgs/msg/TwistWithCovarianceStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

def decode_geometry_msgs_msg_TwistWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['twist'] = decode_geometry_msgs_msg_Twist(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_TwistWithCovariance'](**_fields)

def decode_geometry_msgs_msg_TwistWithCovarianceStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['twist'] = decode_geometry_msgs_msg_TwistWithCovariance(decoder)
    return _dataclass_types['geometry_msgs_msg_TwistWithCovarianceStamped'](**_fields)

# Decoder for geometry_msgs/msg/Vector3
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

# Decoder for geometry_msgs/msg/Vector3Stamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Vector3Stamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['vector'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Vector3Stamped'](**_fields)

# Decoder for geometry_msgs/msg/VelocityStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

def decode_geometry_msgs_msg_VelocityStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['body_frame_id'] = decoder.string()
    _fields['reference_frame_id'] = decoder.string()
    _fields['velocity'] = decode_geometry_msgs_msg_Twist(decoder)
    return _dataclass_types['geometry_msgs_msg_VelocityStamped'](**_fields)

# Decoder for geometry_msgs/msg/Wrench
import struct
def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Wrench(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['force'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['torque'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Wrench'](**_fields)

# Decoder for geometry_msgs/msg/WrenchStamped
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Wrench(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['force'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['torque'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Wrench'](**_fields)

def decode_geometry_msgs_msg_WrenchStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['wrench'] = decode_geometry_msgs_msg_Wrench(decoder)
    return _dataclass_types['geometry_msgs_msg_WrenchStamped'](**_fields)

# Decoder for nav_msgs/msg/Goals
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['pose'] = decode_geometry_msgs_msg_Pose(decoder)
    return _dataclass_types['geometry_msgs_msg_PoseStamped'](**_fields)

def decode_nav_msgs_msg_Goals(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    length = decoder.uint32()
    _fields['goals'] = [decode_geometry_msgs_msg_PoseStamped(decoder) for _ in range(length)]
    return _dataclass_types['nav_msgs_msg_Goals'](**_fields)

# Decoder for nav_msgs/msg/GridCells
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_nav_msgs_msg_GridCells(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    cell_width, cell_height = struct.unpack(fmt_prefix + 'ff', _data.read(8))
    _fields['cell_width'] = cell_width
    _fields['cell_height'] = cell_height
    length = decoder.uint32()
    _fields['cells'] = [decode_geometry_msgs_msg_Point(decoder) for _ in range(length)]
    return _dataclass_types['nav_msgs_msg_GridCells'](**_fields)

# Decoder for nav_msgs/msg/MapMetaData
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_nav_msgs_msg_MapMetaData(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['map_load_time'] = decode_builtin_interfaces_msg_Time(decoder)
    _data.align(4)
    _fields['resolution'] = struct.unpack(fmt_prefix + 'f', _data.read(4))[0]
    _data.align(4)
    width, height = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['width'] = width
    _fields['height'] = height
    _fields['origin'] = decode_geometry_msgs_msg_Pose(decoder)
    return _dataclass_types['nav_msgs_msg_MapMetaData'](**_fields)

# Decoder for nav_msgs/msg/OccupancyGrid
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_nav_msgs_msg_MapMetaData(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['map_load_time'] = decode_builtin_interfaces_msg_Time(decoder)
    _data.align(4)
    _fields['resolution'] = struct.unpack(fmt_prefix + 'f', _data.read(4))[0]
    _data.align(4)
    width, height = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['width'] = width
    _fields['height'] = height
    _fields['origin'] = decode_geometry_msgs_msg_Pose(decoder)
    return _dataclass_types['nav_msgs_msg_MapMetaData'](**_fields)

def decode_nav_msgs_msg_OccupancyGrid(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['info'] = decode_nav_msgs_msg_MapMetaData(decoder)
    _len = decoder.uint32()
    _data.align(1)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'b' * _len, _data.read(1 * _len)))
    return _dataclass_types['nav_msgs_msg_OccupancyGrid'](**_fields)

# Decoder for nav_msgs/msg/Odometry
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['pose'] = decode_geometry_msgs_msg_Pose(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_PoseWithCovariance'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

def decode_geometry_msgs_msg_TwistWithCovariance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['twist'] = decode_geometry_msgs_msg_Twist(decoder)
    _data.align(8)
    _fields['covariance'] = list(struct.unpack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', _data.read(288)))
    return _dataclass_types['geometry_msgs_msg_TwistWithCovariance'](**_fields)

def decode_nav_msgs_msg_Odometry(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['child_frame_id'] = decoder.string()
    _fields['pose'] = decode_geometry_msgs_msg_PoseWithCovariance(decoder)
    _fields['twist'] = decode_geometry_msgs_msg_TwistWithCovariance(decoder)
    return _dataclass_types['nav_msgs_msg_Odometry'](**_fields)

# Decoder for nav_msgs/msg/Path
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Pose(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['position'] = decode_geometry_msgs_msg_Point(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Pose'](**_fields)

def decode_geometry_msgs_msg_PoseStamped(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['pose'] = decode_geometry_msgs_msg_Pose(decoder)
    return _dataclass_types['geometry_msgs_msg_PoseStamped'](**_fields)

def decode_nav_msgs_msg_Path(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    length = decoder.uint32()
    _fields['poses'] = [decode_geometry_msgs_msg_PoseStamped(decoder) for _ in range(length)]
    return _dataclass_types['nav_msgs_msg_Path'](**_fields)

# Decoder for sensor_msgs/msg/BatteryState
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_BatteryState(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    voltage, temperature, current, charge, capacity, design_capacity, percentage = struct.unpack(fmt_prefix + 'fffffff', _data.read(28))
    _fields['voltage'] = voltage
    _fields['temperature'] = temperature
    _fields['current'] = current
    _fields['charge'] = charge
    _fields['capacity'] = capacity
    _fields['design_capacity'] = design_capacity
    _fields['percentage'] = percentage
    _data.align(1)
    power_supply_status, power_supply_health, power_supply_technology = struct.unpack(fmt_prefix + 'BBB', _data.read(3))
    _fields['power_supply_status'] = power_supply_status
    _fields['power_supply_health'] = power_supply_health
    _fields['power_supply_technology'] = power_supply_technology
    _data.align(1)
    _fields['present'] = struct.unpack(fmt_prefix + '?', _data.read(1))[0]
    _len = decoder.uint32()
    _data.align(4)
    _fields['cell_voltage'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    _len = decoder.uint32()
    _data.align(4)
    _fields['cell_temperature'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    _fields['location'] = decoder.string()
    _fields['serial_number'] = decoder.string()
    return _dataclass_types['sensor_msgs_msg_BatteryState'](**_fields)

# Decoder for sensor_msgs/msg/CameraInfo
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_RegionOfInterest(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x_offset, y_offset, height, width = struct.unpack(fmt_prefix + 'IIII', _data.read(16))
    _fields['x_offset'] = x_offset
    _fields['y_offset'] = y_offset
    _fields['height'] = height
    _fields['width'] = width
    _data.align(1)
    _fields['do_rectify'] = struct.unpack(fmt_prefix + '?', _data.read(1))[0]
    return _dataclass_types['sensor_msgs_msg_RegionOfInterest'](**_fields)

def decode_sensor_msgs_msg_CameraInfo(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    height, width = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['height'] = height
    _fields['width'] = width
    _fields['distortion_model'] = decoder.string()
    _len = decoder.uint32()
    _data.align(8)
    _fields['d'] = list(struct.unpack(fmt_prefix + 'd' * _len, _data.read(8 * _len)))
    _data.align(8)
    _fields['k'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    _data.align(8)
    _fields['r'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    _data.align(8)
    _fields['p'] = list(struct.unpack(fmt_prefix + 'dddddddddddd', _data.read(96)))
    _data.align(4)
    binning_x, binning_y = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['binning_x'] = binning_x
    _fields['binning_y'] = binning_y
    _fields['roi'] = decode_sensor_msgs_msg_RegionOfInterest(decoder)
    return _dataclass_types['sensor_msgs_msg_CameraInfo'](**_fields)

# Decoder for sensor_msgs/msg/ChannelFloat32
import struct
def decode_sensor_msgs_msg_ChannelFloat32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['name'] = decoder.string()
    _len = decoder.uint32()
    _data.align(4)
    _fields['values'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    return _dataclass_types['sensor_msgs_msg_ChannelFloat32'](**_fields)

# Decoder for sensor_msgs/msg/CompressedImage
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_CompressedImage(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['format'] = decoder.string()
    _len = decoder.uint32()
    _data.align(1)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'B' * _len, _data.read(1 * _len)))
    return _dataclass_types['sensor_msgs_msg_CompressedImage'](**_fields)

# Decoder for sensor_msgs/msg/FluidPressure
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_FluidPressure(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(8)
    fluid_pressure, variance = struct.unpack(fmt_prefix + 'dd', _data.read(16))
    _fields['fluid_pressure'] = fluid_pressure
    _fields['variance'] = variance
    return _dataclass_types['sensor_msgs_msg_FluidPressure'](**_fields)

# Decoder for sensor_msgs/msg/Illuminance
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_Illuminance(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(8)
    illuminance, variance = struct.unpack(fmt_prefix + 'dd', _data.read(16))
    _fields['illuminance'] = illuminance
    _fields['variance'] = variance
    return _dataclass_types['sensor_msgs_msg_Illuminance'](**_fields)

# Decoder for sensor_msgs/msg/Image
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_Image(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    height, width = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['height'] = height
    _fields['width'] = width
    _fields['encoding'] = decoder.string()
    _data.align(1)
    _fields['is_bigendian'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    _data.align(4)
    _fields['step'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    _len = decoder.uint32()
    _data.align(1)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'B' * _len, _data.read(1 * _len)))
    return _dataclass_types['sensor_msgs_msg_Image'](**_fields)

# Decoder for sensor_msgs/msg/Imu
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_sensor_msgs_msg_Imu(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['orientation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    _data.align(8)
    _fields['orientation_covariance'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    _fields['angular_velocity'] = decode_geometry_msgs_msg_Vector3(decoder)
    _data.align(8)
    _fields['angular_velocity_covariance'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    _fields['linear_acceleration'] = decode_geometry_msgs_msg_Vector3(decoder)
    _data.align(8)
    _fields['linear_acceleration_covariance'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    return _dataclass_types['sensor_msgs_msg_Imu'](**_fields)

# Decoder for sensor_msgs/msg/JointState
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_JointState(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    length = decoder.uint32()
    _fields['name'] = [decoder.string() for _ in range(length)]
    _len = decoder.uint32()
    _data.align(8)
    _fields['position'] = list(struct.unpack(fmt_prefix + 'd' * _len, _data.read(8 * _len)))
    _len = decoder.uint32()
    _data.align(8)
    _fields['velocity'] = list(struct.unpack(fmt_prefix + 'd' * _len, _data.read(8 * _len)))
    _len = decoder.uint32()
    _data.align(8)
    _fields['effort'] = list(struct.unpack(fmt_prefix + 'd' * _len, _data.read(8 * _len)))
    return _dataclass_types['sensor_msgs_msg_JointState'](**_fields)

# Decoder for sensor_msgs/msg/Joy
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_Joy(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _len = decoder.uint32()
    _data.align(4)
    _fields['axes'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    _len = decoder.uint32()
    _data.align(4)
    _fields['buttons'] = list(struct.unpack(fmt_prefix + 'i' * _len, _data.read(4 * _len)))
    return _dataclass_types['sensor_msgs_msg_Joy'](**_fields)

# Decoder for sensor_msgs/msg/JoyFeedback
import struct
def decode_sensor_msgs_msg_JoyFeedback(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    type, id = struct.unpack(fmt_prefix + 'BB', _data.read(2))
    _fields['type'] = type
    _fields['id'] = id
    _data.align(4)
    _fields['intensity'] = struct.unpack(fmt_prefix + 'f', _data.read(4))[0]
    return _dataclass_types['sensor_msgs_msg_JoyFeedback'](**_fields)

# Decoder for sensor_msgs/msg/JoyFeedbackArray
import struct
def decode_sensor_msgs_msg_JoyFeedback(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    type, id = struct.unpack(fmt_prefix + 'BB', _data.read(2))
    _fields['type'] = type
    _fields['id'] = id
    _data.align(4)
    _fields['intensity'] = struct.unpack(fmt_prefix + 'f', _data.read(4))[0]
    return _dataclass_types['sensor_msgs_msg_JoyFeedback'](**_fields)

def decode_sensor_msgs_msg_JoyFeedbackArray(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    length = decoder.uint32()
    _fields['array'] = [decode_sensor_msgs_msg_JoyFeedback(decoder) for _ in range(length)]
    return _dataclass_types['sensor_msgs_msg_JoyFeedbackArray'](**_fields)

# Decoder for sensor_msgs/msg/LaserEcho
import struct
def decode_sensor_msgs_msg_LaserEcho(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _len = decoder.uint32()
    _data.align(4)
    _fields['echoes'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    return _dataclass_types['sensor_msgs_msg_LaserEcho'](**_fields)

# Decoder for sensor_msgs/msg/LaserScan
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_LaserScan(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    angle_min, angle_max, angle_increment, time_increment, scan_time, range_min, range_max = struct.unpack(fmt_prefix + 'fffffff', _data.read(28))
    _fields['angle_min'] = angle_min
    _fields['angle_max'] = angle_max
    _fields['angle_increment'] = angle_increment
    _fields['time_increment'] = time_increment
    _fields['scan_time'] = scan_time
    _fields['range_min'] = range_min
    _fields['range_max'] = range_max
    _len = decoder.uint32()
    _data.align(4)
    _fields['ranges'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    _len = decoder.uint32()
    _data.align(4)
    _fields['intensities'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    return _dataclass_types['sensor_msgs_msg_LaserScan'](**_fields)

# Decoder for sensor_msgs/msg/MagneticField
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_sensor_msgs_msg_MagneticField(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['magnetic_field'] = decode_geometry_msgs_msg_Vector3(decoder)
    _data.align(8)
    _fields['magnetic_field_covariance'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    return _dataclass_types['sensor_msgs_msg_MagneticField'](**_fields)

# Decoder for sensor_msgs/msg/MultiDOFJointState
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Vector3(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Vector3'](**_fields)

def decode_geometry_msgs_msg_Quaternion(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(8)
    x, y, z, w = struct.unpack(fmt_prefix + 'dddd', _data.read(32))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    _fields['w'] = w
    return _dataclass_types['geometry_msgs_msg_Quaternion'](**_fields)

def decode_geometry_msgs_msg_Transform(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['translation'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['rotation'] = decode_geometry_msgs_msg_Quaternion(decoder)
    return _dataclass_types['geometry_msgs_msg_Transform'](**_fields)

def decode_geometry_msgs_msg_Twist(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['linear'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['angular'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Twist'](**_fields)

def decode_geometry_msgs_msg_Wrench(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['force'] = decode_geometry_msgs_msg_Vector3(decoder)
    _fields['torque'] = decode_geometry_msgs_msg_Vector3(decoder)
    return _dataclass_types['geometry_msgs_msg_Wrench'](**_fields)

def decode_sensor_msgs_msg_MultiDOFJointState(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    length = decoder.uint32()
    _fields['joint_names'] = [decoder.string() for _ in range(length)]
    length = decoder.uint32()
    _fields['transforms'] = [decode_geometry_msgs_msg_Transform(decoder) for _ in range(length)]
    length = decoder.uint32()
    _fields['twist'] = [decode_geometry_msgs_msg_Twist(decoder) for _ in range(length)]
    length = decoder.uint32()
    _fields['wrench'] = [decode_geometry_msgs_msg_Wrench(decoder) for _ in range(length)]
    return _dataclass_types['sensor_msgs_msg_MultiDOFJointState'](**_fields)

# Decoder for sensor_msgs/msg/MultiEchoLaserScan
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_LaserEcho(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _len = decoder.uint32()
    _data.align(4)
    _fields['echoes'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    return _dataclass_types['sensor_msgs_msg_LaserEcho'](**_fields)

def decode_sensor_msgs_msg_MultiEchoLaserScan(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    angle_min, angle_max, angle_increment, time_increment, scan_time, range_min, range_max = struct.unpack(fmt_prefix + 'fffffff', _data.read(28))
    _fields['angle_min'] = angle_min
    _fields['angle_max'] = angle_max
    _fields['angle_increment'] = angle_increment
    _fields['time_increment'] = time_increment
    _fields['scan_time'] = scan_time
    _fields['range_min'] = range_min
    _fields['range_max'] = range_max
    length = decoder.uint32()
    _fields['ranges'] = [decode_sensor_msgs_msg_LaserEcho(decoder) for _ in range(length)]
    length = decoder.uint32()
    _fields['intensities'] = [decode_sensor_msgs_msg_LaserEcho(decoder) for _ in range(length)]
    return _dataclass_types['sensor_msgs_msg_MultiEchoLaserScan'](**_fields)

# Decoder for sensor_msgs/msg/NavSatFix
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_NavSatStatus(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    _fields['status'] = struct.unpack(fmt_prefix + 'b', _data.read(1))[0]
    _data.align(2)
    _fields['service'] = struct.unpack(fmt_prefix + 'H', _data.read(2))[0]
    return _dataclass_types['sensor_msgs_msg_NavSatStatus'](**_fields)

def decode_sensor_msgs_msg_NavSatFix(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['status'] = decode_sensor_msgs_msg_NavSatStatus(decoder)
    _data.align(8)
    latitude, longitude, altitude = struct.unpack(fmt_prefix + 'ddd', _data.read(24))
    _fields['latitude'] = latitude
    _fields['longitude'] = longitude
    _fields['altitude'] = altitude
    _data.align(8)
    _fields['position_covariance'] = list(struct.unpack(fmt_prefix + 'ddddddddd', _data.read(72)))
    _data.align(1)
    _fields['position_covariance_type'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    return _dataclass_types['sensor_msgs_msg_NavSatFix'](**_fields)

# Decoder for sensor_msgs/msg/NavSatStatus
import struct
def decode_sensor_msgs_msg_NavSatStatus(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(1)
    _fields['status'] = struct.unpack(fmt_prefix + 'b', _data.read(1))[0]
    _data.align(2)
    _fields['service'] = struct.unpack(fmt_prefix + 'H', _data.read(2))[0]
    return _dataclass_types['sensor_msgs_msg_NavSatStatus'](**_fields)

# Decoder for sensor_msgs/msg/PointCloud
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_geometry_msgs_msg_Point32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x, y, z = struct.unpack(fmt_prefix + 'fff', _data.read(12))
    _fields['x'] = x
    _fields['y'] = y
    _fields['z'] = z
    return _dataclass_types['geometry_msgs_msg_Point32'](**_fields)

def decode_sensor_msgs_msg_ChannelFloat32(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['name'] = decoder.string()
    _len = decoder.uint32()
    _data.align(4)
    _fields['values'] = list(struct.unpack(fmt_prefix + 'f' * _len, _data.read(4 * _len)))
    return _dataclass_types['sensor_msgs_msg_ChannelFloat32'](**_fields)

def decode_sensor_msgs_msg_PointCloud(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    length = decoder.uint32()
    _fields['points'] = [decode_geometry_msgs_msg_Point32(decoder) for _ in range(length)]
    length = decoder.uint32()
    _fields['channels'] = [decode_sensor_msgs_msg_ChannelFloat32(decoder) for _ in range(length)]
    return _dataclass_types['sensor_msgs_msg_PointCloud'](**_fields)

# Decoder for sensor_msgs/msg/PointCloud2
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_PointField(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['name'] = decoder.string()
    _data.align(4)
    _fields['offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    _data.align(1)
    _fields['datatype'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    _data.align(4)
    _fields['count'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['sensor_msgs_msg_PointField'](**_fields)

def decode_sensor_msgs_msg_PointCloud2(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(4)
    height, width = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['height'] = height
    _fields['width'] = width
    length = decoder.uint32()
    _fields['fields'] = [decode_sensor_msgs_msg_PointField(decoder) for _ in range(length)]
    _data.align(1)
    _fields['is_bigendian'] = struct.unpack(fmt_prefix + '?', _data.read(1))[0]
    _data.align(4)
    point_step, row_step = struct.unpack(fmt_prefix + 'II', _data.read(8))
    _fields['point_step'] = point_step
    _fields['row_step'] = row_step
    _len = decoder.uint32()
    _data.align(1)
    _fields['data'] = list(struct.unpack(fmt_prefix + 'B' * _len, _data.read(1 * _len)))
    _data.align(1)
    _fields['is_dense'] = struct.unpack(fmt_prefix + '?', _data.read(1))[0]
    return _dataclass_types['sensor_msgs_msg_PointCloud2'](**_fields)

# Decoder for sensor_msgs/msg/PointField
import struct
def decode_sensor_msgs_msg_PointField(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['name'] = decoder.string()
    _data.align(4)
    _fields['offset'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    _data.align(1)
    _fields['datatype'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    _data.align(4)
    _fields['count'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['sensor_msgs_msg_PointField'](**_fields)

# Decoder for sensor_msgs/msg/Range
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_Range(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(1)
    _fields['radiation_type'] = struct.unpack(fmt_prefix + 'B', _data.read(1))[0]
    _data.align(4)
    field_of_view, min_range, max_range, range = struct.unpack(fmt_prefix + 'ffff', _data.read(16))
    _fields['field_of_view'] = field_of_view
    _fields['min_range'] = min_range
    _fields['max_range'] = max_range
    _fields['range'] = range
    return _dataclass_types['sensor_msgs_msg_Range'](**_fields)

# Decoder for sensor_msgs/msg/RegionOfInterest
import struct
def decode_sensor_msgs_msg_RegionOfInterest(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    x_offset, y_offset, height, width = struct.unpack(fmt_prefix + 'IIII', _data.read(16))
    _fields['x_offset'] = x_offset
    _fields['y_offset'] = y_offset
    _fields['height'] = height
    _fields['width'] = width
    _data.align(1)
    _fields['do_rectify'] = struct.unpack(fmt_prefix + '?', _data.read(1))[0]
    return _dataclass_types['sensor_msgs_msg_RegionOfInterest'](**_fields)

# Decoder for sensor_msgs/msg/RelativeHumidity
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_RelativeHumidity(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(8)
    relative_humidity, variance = struct.unpack(fmt_prefix + 'dd', _data.read(16))
    _fields['relative_humidity'] = relative_humidity
    _fields['variance'] = variance
    return _dataclass_types['sensor_msgs_msg_RelativeHumidity'](**_fields)

# Decoder for sensor_msgs/msg/Temperature
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_Temperature(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _data.align(8)
    temperature, variance = struct.unpack(fmt_prefix + 'dd', _data.read(16))
    _fields['temperature'] = temperature
    _fields['variance'] = variance
    return _dataclass_types['sensor_msgs_msg_Temperature'](**_fields)

# Decoder for sensor_msgs/msg/TimeReference
import struct
def decode_builtin_interfaces_msg_Time(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _data.align(4)
    _fields['sec'] = struct.unpack(fmt_prefix + 'i', _data.read(4))[0]
    _data.align(4)
    _fields['nanosec'] = struct.unpack(fmt_prefix + 'I', _data.read(4))[0]
    return _dataclass_types['builtin_interfaces_msg_Time'](**_fields)

def decode_std_msgs_msg_Header(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['stamp'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['frame_id'] = decoder.string()
    return _dataclass_types['std_msgs_msg_Header'](**_fields)

def decode_sensor_msgs_msg_TimeReference(decoder):
    fmt_prefix = '<' if decoder._is_little_endian else '>'
    _data = decoder._data
    _fields = {}
    _fields['header'] = decode_std_msgs_msg_Header(decoder)
    _fields['time_ref'] = decode_builtin_interfaces_msg_Time(decoder)
    _fields['source'] = decoder.string()
    return _dataclass_types['sensor_msgs_msg_TimeReference'](**_fields)

# ==================== ENCODER FUNCTIONS ====================

# Encoder for builtin_interfaces/msg/Duration
import struct
def encode_builtin_interfaces_msg_Duration(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

# Encoder for builtin_interfaces/msg/Time
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

# Encoder for std_msgs/msg/Bool
import struct
def encode_std_msgs_msg_Bool(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + '?', message.data))

# Encoder for std_msgs/msg/Byte
import struct
def encode_std_msgs_msg_Byte(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _value = message.data
    if isinstance(_value, str):
        _value = ord(_value)
    elif isinstance(_value, (bytes, bytearray)):
        _value = _value[0]
    _payload.write(struct_pack(fmt_prefix + 'B', _value))

# Encoder for std_msgs/msg/ByteMultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_ByteMultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        if isinstance(_item, str):
            _payload.write(struct_pack(fmt_prefix + 'B', ord(_item)))
        elif isinstance(_item, (bytes, bytearray)):
            _payload.write(struct_pack(fmt_prefix + 'B', _item[0]))
        else:
            _payload.write(struct_pack(fmt_prefix + 'B', _item))

# Encoder for std_msgs/msg/Char
import struct
def encode_std_msgs_msg_Char(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _value = message.data
    if isinstance(_value, str):
        _value = ord(_value)
    elif isinstance(_value, (bytes, bytearray)):
        _value = _value[0]
    _payload.write(struct_pack(fmt_prefix + 'B', _value))

# Encoder for std_msgs/msg/ColorRGBA
import struct
def encode_std_msgs_msg_ColorRGBA(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.r))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.g))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.b))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.a))

# Encoder for std_msgs/msg/Empty
import struct
def encode_std_msgs_msg_Empty(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.structure_needs_at_least_one_member))

# Encoder for std_msgs/msg/Float32
import struct
def encode_std_msgs_msg_Float32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.data))

# Encoder for std_msgs/msg/Float32MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_Float32MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(4)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))

# Encoder for std_msgs/msg/Float64
import struct
def encode_std_msgs_msg_Float64(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.data))

# Encoder for std_msgs/msg/Float64MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_Float64MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(8)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'd', _item))

# Encoder for std_msgs/msg/Header
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

# Encoder for std_msgs/msg/Int16
import struct
def encode_std_msgs_msg_Int16(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(2)
    _payload.write(struct_pack(fmt_prefix + 'h', message.data))

# Encoder for std_msgs/msg/Int16MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_Int16MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(2)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'h', _item))

# Encoder for std_msgs/msg/Int32
import struct
def encode_std_msgs_msg_Int32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.data))

# Encoder for std_msgs/msg/Int32MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_Int32MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(4)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'i', _item))

# Encoder for std_msgs/msg/Int64
import struct
def encode_std_msgs_msg_Int64(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'q', message.data))

# Encoder for std_msgs/msg/Int64MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_Int64MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(8)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'q', _item))

# Encoder for std_msgs/msg/Int8
import struct
def encode_std_msgs_msg_Int8(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'b', message.data))

# Encoder for std_msgs/msg/Int8MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_Int8MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'b', _item))

# Encoder for std_msgs/msg/MultiArrayDimension
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

# Encoder for std_msgs/msg/MultiArrayLayout
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

# Encoder for std_msgs/msg/String
import struct
def encode_std_msgs_msg_String(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.data)

# Encoder for std_msgs/msg/UInt16
import struct
def encode_std_msgs_msg_UInt16(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(2)
    _payload.write(struct_pack(fmt_prefix + 'H', message.data))

# Encoder for std_msgs/msg/UInt16MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_UInt16MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(2)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'H', _item))

# Encoder for std_msgs/msg/UInt32
import struct
def encode_std_msgs_msg_UInt32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data))

# Encoder for std_msgs/msg/UInt32MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_UInt32MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(4)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'I', _item))

# Encoder for std_msgs/msg/UInt64
import struct
def encode_std_msgs_msg_UInt64(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'Q', message.data))

# Encoder for std_msgs/msg/UInt64MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_UInt64MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(8)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'Q', _item))

# Encoder for std_msgs/msg/UInt8
import struct
def encode_std_msgs_msg_UInt8(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.data))

# Encoder for std_msgs/msg/UInt8MultiArray
import struct
def encode_std_msgs_msg_MultiArrayDimension(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.label)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.size))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.stride))

def encode_std_msgs_msg_MultiArrayLayout(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.dim))
    for _item in message.dim:
        encode_std_msgs_msg_MultiArrayDimension(encoder, _item)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.data_offset))

def encode_std_msgs_msg_UInt8MultiArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_MultiArrayLayout(encoder, message.layout)
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'B', _item))

# Encoder for geometry_msgs/msg/Accel
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Accel(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

# Encoder for geometry_msgs/msg/AccelStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Accel(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_AccelStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Accel(encoder, message.accel)

# Encoder for geometry_msgs/msg/AccelWithCovariance
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Accel(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_AccelWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Accel(encoder, message.accel)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

# Encoder for geometry_msgs/msg/AccelWithCovarianceStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Accel(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_AccelWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Accel(encoder, message.accel)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

def encode_geometry_msgs_msg_AccelWithCovarianceStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_AccelWithCovariance(encoder, message.accel)

# Encoder for geometry_msgs/msg/Inertia
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Inertia(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.m))
    encode_geometry_msgs_msg_Vector3(encoder, message.com)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.ixx))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.ixy))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.ixz))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.iyy))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.iyz))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.izz))

# Encoder for geometry_msgs/msg/InertiaStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Inertia(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.m))
    encode_geometry_msgs_msg_Vector3(encoder, message.com)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.ixx))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.ixy))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.ixz))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.iyy))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.iyz))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.izz))

def encode_geometry_msgs_msg_InertiaStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Inertia(encoder, message.inertia)

# Encoder for geometry_msgs/msg/Point
import struct
def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

# Encoder for geometry_msgs/msg/Point32
import struct
def encode_geometry_msgs_msg_Point32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.y))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.z))

# Encoder for geometry_msgs/msg/PointStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_PointStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Point(encoder, message.point)

# Encoder for geometry_msgs/msg/Polygon
import struct
def encode_geometry_msgs_msg_Point32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.y))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.z))

def encode_geometry_msgs_msg_Polygon(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.points))
    for _item in message.points:
        encode_geometry_msgs_msg_Point32(encoder, _item)

# Encoder for geometry_msgs/msg/PolygonInstance
import struct
def encode_geometry_msgs_msg_Point32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.y))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.z))

def encode_geometry_msgs_msg_Polygon(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.points))
    for _item in message.points:
        encode_geometry_msgs_msg_Point32(encoder, _item)

def encode_geometry_msgs_msg_PolygonInstance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Polygon(encoder, message.polygon)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'q', message.id))

# Encoder for geometry_msgs/msg/PolygonInstanceStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.y))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.z))

def encode_geometry_msgs_msg_Polygon(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.points))
    for _item in message.points:
        encode_geometry_msgs_msg_Point32(encoder, _item)

def encode_geometry_msgs_msg_PolygonInstance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Polygon(encoder, message.polygon)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'q', message.id))

def encode_geometry_msgs_msg_PolygonInstanceStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_PolygonInstance(encoder, message.polygon)

# Encoder for geometry_msgs/msg/PolygonStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.y))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.z))

def encode_geometry_msgs_msg_Polygon(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.points))
    for _item in message.points:
        encode_geometry_msgs_msg_Point32(encoder, _item)

def encode_geometry_msgs_msg_PolygonStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Polygon(encoder, message.polygon)

# Encoder for geometry_msgs/msg/Pose
import struct
def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

# Encoder for geometry_msgs/msg/Pose2D
import struct
def encode_geometry_msgs_msg_Pose2D(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.theta))

# Encoder for geometry_msgs/msg/PoseArray
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.poses))
    for _item in message.poses:
        encode_geometry_msgs_msg_Pose(encoder, _item)

# Encoder for geometry_msgs/msg/PoseStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Pose(encoder, message.pose)

# Encoder for geometry_msgs/msg/PoseWithCovariance
import struct
def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Pose(encoder, message.pose)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

# Encoder for geometry_msgs/msg/PoseWithCovarianceStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Pose(encoder, message.pose)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

def encode_geometry_msgs_msg_PoseWithCovarianceStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_PoseWithCovariance(encoder, message.pose)

# Encoder for geometry_msgs/msg/Quaternion
import struct
def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

# Encoder for geometry_msgs/msg/QuaternionStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_QuaternionStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Quaternion(encoder, message.quaternion)

# Encoder for geometry_msgs/msg/Transform
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Transform(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.translation)
    encode_geometry_msgs_msg_Quaternion(encoder, message.rotation)

# Encoder for geometry_msgs/msg/TransformStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Transform(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.translation)
    encode_geometry_msgs_msg_Quaternion(encoder, message.rotation)

def encode_geometry_msgs_msg_TransformStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.string(message.child_frame_id)
    encode_geometry_msgs_msg_Transform(encoder, message.transform)

# Encoder for geometry_msgs/msg/Twist
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

# Encoder for geometry_msgs/msg/TwistStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_TwistStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Twist(encoder, message.twist)

# Encoder for geometry_msgs/msg/TwistWithCovariance
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_TwistWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Twist(encoder, message.twist)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

# Encoder for geometry_msgs/msg/TwistWithCovarianceStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_TwistWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Twist(encoder, message.twist)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

def encode_geometry_msgs_msg_TwistWithCovarianceStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_TwistWithCovariance(encoder, message.twist)

# Encoder for geometry_msgs/msg/Vector3
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

# Encoder for geometry_msgs/msg/Vector3Stamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Vector3Stamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Vector3(encoder, message.vector)

# Encoder for geometry_msgs/msg/VelocityStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_VelocityStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.string(message.body_frame_id)
    encoder.string(message.reference_frame_id)
    encode_geometry_msgs_msg_Twist(encoder, message.velocity)

# Encoder for geometry_msgs/msg/Wrench
import struct
def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Wrench(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.force)
    encode_geometry_msgs_msg_Vector3(encoder, message.torque)

# Encoder for geometry_msgs/msg/WrenchStamped
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Wrench(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.force)
    encode_geometry_msgs_msg_Vector3(encoder, message.torque)

def encode_geometry_msgs_msg_WrenchStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Wrench(encoder, message.wrench)

# Encoder for nav_msgs/msg/Goals
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Pose(encoder, message.pose)

def encode_nav_msgs_msg_Goals(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.goals))
    for _item in message.goals:
        encode_geometry_msgs_msg_PoseStamped(encoder, _item)

# Encoder for nav_msgs/msg/GridCells
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_nav_msgs_msg_GridCells(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.cell_width))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.cell_height))
    encoder.uint32(len(message.cells))
    for _item in message.cells:
        encode_geometry_msgs_msg_Point(encoder, _item)

# Encoder for nav_msgs/msg/MapMetaData
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_nav_msgs_msg_MapMetaData(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.map_load_time)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.resolution))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    encode_geometry_msgs_msg_Pose(encoder, message.origin)

# Encoder for nav_msgs/msg/OccupancyGrid
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_nav_msgs_msg_MapMetaData(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.map_load_time)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.resolution))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    encode_geometry_msgs_msg_Pose(encoder, message.origin)

def encode_nav_msgs_msg_OccupancyGrid(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_nav_msgs_msg_MapMetaData(encoder, message.info)
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'b', _item))

# Encoder for nav_msgs/msg/Odometry
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Pose(encoder, message.pose)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_TwistWithCovariance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Twist(encoder, message.twist)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddddddddddddddddddddddddddd', *message.covariance))

def encode_nav_msgs_msg_Odometry(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.string(message.child_frame_id)
    encode_geometry_msgs_msg_PoseWithCovariance(encoder, message.pose)
    encode_geometry_msgs_msg_TwistWithCovariance(encoder, message.twist)

# Encoder for nav_msgs/msg/Path
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Pose(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Point(encoder, message.position)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)

def encode_geometry_msgs_msg_PoseStamped(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Pose(encoder, message.pose)

def encode_nav_msgs_msg_Path(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.poses))
    for _item in message.poses:
        encode_geometry_msgs_msg_PoseStamped(encoder, _item)

# Encoder for sensor_msgs/msg/BatteryState
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_BatteryState(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.voltage))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.temperature))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.current))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.charge))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.capacity))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.design_capacity))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.percentage))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.power_supply_status))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.power_supply_health))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.power_supply_technology))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + '?', message.present))
    encoder.uint32(len(message.cell_voltage))
    _payload.align(4)
    for _item in message.cell_voltage:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))
    encoder.uint32(len(message.cell_temperature))
    _payload.align(4)
    for _item in message.cell_temperature:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))
    encoder.string(message.location)
    encoder.string(message.serial_number)

# Encoder for sensor_msgs/msg/CameraInfo
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_RegionOfInterest(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.x_offset))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.y_offset))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + '?', message.do_rectify))

def encode_sensor_msgs_msg_CameraInfo(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    encoder.string(message.distortion_model)
    encoder.uint32(len(message.d))
    _payload.align(8)
    for _item in message.d:
        _payload.write(struct_pack(fmt_prefix + 'd', _item))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.k))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.r))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'dddddddddddd', *message.p))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.binning_x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.binning_y))
    encode_sensor_msgs_msg_RegionOfInterest(encoder, message.roi)

# Encoder for sensor_msgs/msg/ChannelFloat32
import struct
def encode_sensor_msgs_msg_ChannelFloat32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.name)
    encoder.uint32(len(message.values))
    _payload.align(4)
    for _item in message.values:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))

# Encoder for sensor_msgs/msg/CompressedImage
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_CompressedImage(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.string(message.format)
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'B', _item))

# Encoder for sensor_msgs/msg/FluidPressure
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_FluidPressure(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.fluid_pressure))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.variance))

# Encoder for sensor_msgs/msg/Illuminance
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_Illuminance(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.illuminance))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.variance))

# Encoder for sensor_msgs/msg/Image
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_Image(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    encoder.string(message.encoding)
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.is_bigendian))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.step))
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'B', _item))

# Encoder for sensor_msgs/msg/Imu
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_sensor_msgs_msg_Imu(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Quaternion(encoder, message.orientation)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.orientation_covariance))
    encode_geometry_msgs_msg_Vector3(encoder, message.angular_velocity)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.angular_velocity_covariance))
    encode_geometry_msgs_msg_Vector3(encoder, message.linear_acceleration)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.linear_acceleration_covariance))

# Encoder for sensor_msgs/msg/JointState
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_JointState(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.name))
    for _item in message.name:
        encoder.string(_item)
    encoder.uint32(len(message.position))
    _payload.align(8)
    for _item in message.position:
        _payload.write(struct_pack(fmt_prefix + 'd', _item))
    encoder.uint32(len(message.velocity))
    _payload.align(8)
    for _item in message.velocity:
        _payload.write(struct_pack(fmt_prefix + 'd', _item))
    encoder.uint32(len(message.effort))
    _payload.align(8)
    for _item in message.effort:
        _payload.write(struct_pack(fmt_prefix + 'd', _item))

# Encoder for sensor_msgs/msg/Joy
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_Joy(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.axes))
    _payload.align(4)
    for _item in message.axes:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))
    encoder.uint32(len(message.buttons))
    _payload.align(4)
    for _item in message.buttons:
        _payload.write(struct_pack(fmt_prefix + 'i', _item))

# Encoder for sensor_msgs/msg/JoyFeedback
import struct
def encode_sensor_msgs_msg_JoyFeedback(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.type))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.id))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.intensity))

# Encoder for sensor_msgs/msg/JoyFeedbackArray
import struct
def encode_sensor_msgs_msg_JoyFeedback(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.type))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.id))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.intensity))

def encode_sensor_msgs_msg_JoyFeedbackArray(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.array))
    for _item in message.array:
        encode_sensor_msgs_msg_JoyFeedback(encoder, _item)

# Encoder for sensor_msgs/msg/LaserEcho
import struct
def encode_sensor_msgs_msg_LaserEcho(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.echoes))
    _payload.align(4)
    for _item in message.echoes:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))

# Encoder for sensor_msgs/msg/LaserScan
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_LaserScan(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.angle_min))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.angle_max))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.angle_increment))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.time_increment))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.scan_time))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.range_min))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.range_max))
    encoder.uint32(len(message.ranges))
    _payload.align(4)
    for _item in message.ranges:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))
    encoder.uint32(len(message.intensities))
    _payload.align(4)
    for _item in message.intensities:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))

# Encoder for sensor_msgs/msg/MagneticField
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_sensor_msgs_msg_MagneticField(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_geometry_msgs_msg_Vector3(encoder, message.magnetic_field)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.magnetic_field_covariance))

# Encoder for sensor_msgs/msg/MultiDOFJointState
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Vector3(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))

def encode_geometry_msgs_msg_Quaternion(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.x))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.y))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.z))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.w))

def encode_geometry_msgs_msg_Transform(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.translation)
    encode_geometry_msgs_msg_Quaternion(encoder, message.rotation)

def encode_geometry_msgs_msg_Twist(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.linear)
    encode_geometry_msgs_msg_Vector3(encoder, message.angular)

def encode_geometry_msgs_msg_Wrench(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_geometry_msgs_msg_Vector3(encoder, message.force)
    encode_geometry_msgs_msg_Vector3(encoder, message.torque)

def encode_sensor_msgs_msg_MultiDOFJointState(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.joint_names))
    for _item in message.joint_names:
        encoder.string(_item)
    encoder.uint32(len(message.transforms))
    for _item in message.transforms:
        encode_geometry_msgs_msg_Transform(encoder, _item)
    encoder.uint32(len(message.twist))
    for _item in message.twist:
        encode_geometry_msgs_msg_Twist(encoder, _item)
    encoder.uint32(len(message.wrench))
    for _item in message.wrench:
        encode_geometry_msgs_msg_Wrench(encoder, _item)

# Encoder for sensor_msgs/msg/MultiEchoLaserScan
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_LaserEcho(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.uint32(len(message.echoes))
    _payload.align(4)
    for _item in message.echoes:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))

def encode_sensor_msgs_msg_MultiEchoLaserScan(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.angle_min))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.angle_max))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.angle_increment))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.time_increment))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.scan_time))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.range_min))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.range_max))
    encoder.uint32(len(message.ranges))
    for _item in message.ranges:
        encode_sensor_msgs_msg_LaserEcho(encoder, _item)
    encoder.uint32(len(message.intensities))
    for _item in message.intensities:
        encode_sensor_msgs_msg_LaserEcho(encoder, _item)

# Encoder for sensor_msgs/msg/NavSatFix
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_NavSatStatus(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'b', message.status))
    _payload.align(2)
    _payload.write(struct_pack(fmt_prefix + 'H', message.service))

def encode_sensor_msgs_msg_NavSatFix(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_sensor_msgs_msg_NavSatStatus(encoder, message.status)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.latitude))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.longitude))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.altitude))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'ddddddddd', *message.position_covariance))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.position_covariance_type))

# Encoder for sensor_msgs/msg/NavSatStatus
import struct
def encode_sensor_msgs_msg_NavSatStatus(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'b', message.status))
    _payload.align(2)
    _payload.write(struct_pack(fmt_prefix + 'H', message.service))

# Encoder for sensor_msgs/msg/PointCloud
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_geometry_msgs_msg_Point32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.x))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.y))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.z))

def encode_sensor_msgs_msg_ChannelFloat32(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.name)
    encoder.uint32(len(message.values))
    _payload.align(4)
    for _item in message.values:
        _payload.write(struct_pack(fmt_prefix + 'f', _item))

def encode_sensor_msgs_msg_PointCloud(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encoder.uint32(len(message.points))
    for _item in message.points:
        encode_geometry_msgs_msg_Point32(encoder, _item)
    encoder.uint32(len(message.channels))
    for _item in message.channels:
        encode_sensor_msgs_msg_ChannelFloat32(encoder, _item)

# Encoder for sensor_msgs/msg/PointCloud2
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_PointField(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.name)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.offset))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.datatype))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.count))

def encode_sensor_msgs_msg_PointCloud2(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    encoder.uint32(len(message.fields))
    for _item in message.fields:
        encode_sensor_msgs_msg_PointField(encoder, _item)
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + '?', message.is_bigendian))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.point_step))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.row_step))
    encoder.uint32(len(message.data))
    _payload.align(1)
    for _item in message.data:
        _payload.write(struct_pack(fmt_prefix + 'B', _item))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + '?', message.is_dense))

# Encoder for sensor_msgs/msg/PointField
import struct
def encode_sensor_msgs_msg_PointField(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encoder.string(message.name)
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.offset))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.datatype))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.count))

# Encoder for sensor_msgs/msg/Range
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_Range(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + 'B', message.radiation_type))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.field_of_view))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.min_range))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.max_range))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'f', message.range))

# Encoder for sensor_msgs/msg/RegionOfInterest
import struct
def encode_sensor_msgs_msg_RegionOfInterest(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.x_offset))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.y_offset))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.height))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.width))
    _payload.align(1)
    _payload.write(struct_pack(fmt_prefix + '?', message.do_rectify))

# Encoder for sensor_msgs/msg/RelativeHumidity
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_RelativeHumidity(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.relative_humidity))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.variance))

# Encoder for sensor_msgs/msg/Temperature
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_Temperature(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.temperature))
    _payload.align(8)
    _payload.write(struct_pack(fmt_prefix + 'd', message.variance))

# Encoder for sensor_msgs/msg/TimeReference
import struct
def encode_builtin_interfaces_msg_Time(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'i', message.sec))
    _payload.align(4)
    _payload.write(struct_pack(fmt_prefix + 'I', message.nanosec))

def encode_std_msgs_msg_Header(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_builtin_interfaces_msg_Time(encoder, message.stamp)
    encoder.string(message.frame_id)

def encode_sensor_msgs_msg_TimeReference(encoder, message):
    fmt_prefix = '<' if encoder._is_little_endian else '>'
    _payload = encoder._payload
    struct_pack = struct.pack
    encode_std_msgs_msg_Header(encoder, message.header)
    encode_builtin_interfaces_msg_Time(encoder, message.time_ref)
    encoder.string(message.source)

# ==================== MESSAGE REGISTRY ====================

# Maps message names to (decoder_func, encoder_func) tuples
MESSAGE_REGISTRY: dict[str, tuple[str, str]] = {
    'builtin_interfaces/msg/Duration': ('decode_builtin_interfaces_msg_Duration', 'encode_builtin_interfaces_msg_Duration'),
    'builtin_interfaces/msg/Time': ('decode_builtin_interfaces_msg_Time', 'encode_builtin_interfaces_msg_Time'),
    'geometry_msgs/msg/Accel': ('decode_geometry_msgs_msg_Accel', 'encode_geometry_msgs_msg_Accel'),
    'geometry_msgs/msg/AccelStamped': ('decode_geometry_msgs_msg_AccelStamped', 'encode_geometry_msgs_msg_AccelStamped'),
    'geometry_msgs/msg/AccelWithCovariance': ('decode_geometry_msgs_msg_AccelWithCovariance', 'encode_geometry_msgs_msg_AccelWithCovariance'),
    'geometry_msgs/msg/AccelWithCovarianceStamped': ('decode_geometry_msgs_msg_AccelWithCovarianceStamped', 'encode_geometry_msgs_msg_AccelWithCovarianceStamped'),
    'geometry_msgs/msg/Inertia': ('decode_geometry_msgs_msg_Inertia', 'encode_geometry_msgs_msg_Inertia'),
    'geometry_msgs/msg/InertiaStamped': ('decode_geometry_msgs_msg_InertiaStamped', 'encode_geometry_msgs_msg_InertiaStamped'),
    'geometry_msgs/msg/Point': ('decode_geometry_msgs_msg_Point', 'encode_geometry_msgs_msg_Point'),
    'geometry_msgs/msg/Point32': ('decode_geometry_msgs_msg_Point32', 'encode_geometry_msgs_msg_Point32'),
    'geometry_msgs/msg/PointStamped': ('decode_geometry_msgs_msg_PointStamped', 'encode_geometry_msgs_msg_PointStamped'),
    'geometry_msgs/msg/Polygon': ('decode_geometry_msgs_msg_Polygon', 'encode_geometry_msgs_msg_Polygon'),
    'geometry_msgs/msg/PolygonInstance': ('decode_geometry_msgs_msg_PolygonInstance', 'encode_geometry_msgs_msg_PolygonInstance'),
    'geometry_msgs/msg/PolygonInstanceStamped': ('decode_geometry_msgs_msg_PolygonInstanceStamped', 'encode_geometry_msgs_msg_PolygonInstanceStamped'),
    'geometry_msgs/msg/PolygonStamped': ('decode_geometry_msgs_msg_PolygonStamped', 'encode_geometry_msgs_msg_PolygonStamped'),
    'geometry_msgs/msg/Pose': ('decode_geometry_msgs_msg_Pose', 'encode_geometry_msgs_msg_Pose'),
    'geometry_msgs/msg/Pose2D': ('decode_geometry_msgs_msg_Pose2D', 'encode_geometry_msgs_msg_Pose2D'),
    'geometry_msgs/msg/PoseArray': ('decode_geometry_msgs_msg_PoseArray', 'encode_geometry_msgs_msg_PoseArray'),
    'geometry_msgs/msg/PoseStamped': ('decode_geometry_msgs_msg_PoseStamped', 'encode_geometry_msgs_msg_PoseStamped'),
    'geometry_msgs/msg/PoseWithCovariance': ('decode_geometry_msgs_msg_PoseWithCovariance', 'encode_geometry_msgs_msg_PoseWithCovariance'),
    'geometry_msgs/msg/PoseWithCovarianceStamped': ('decode_geometry_msgs_msg_PoseWithCovarianceStamped', 'encode_geometry_msgs_msg_PoseWithCovarianceStamped'),
    'geometry_msgs/msg/Quaternion': ('decode_geometry_msgs_msg_Quaternion', 'encode_geometry_msgs_msg_Quaternion'),
    'geometry_msgs/msg/QuaternionStamped': ('decode_geometry_msgs_msg_QuaternionStamped', 'encode_geometry_msgs_msg_QuaternionStamped'),
    'geometry_msgs/msg/Transform': ('decode_geometry_msgs_msg_Transform', 'encode_geometry_msgs_msg_Transform'),
    'geometry_msgs/msg/TransformStamped': ('decode_geometry_msgs_msg_TransformStamped', 'encode_geometry_msgs_msg_TransformStamped'),
    'geometry_msgs/msg/Twist': ('decode_geometry_msgs_msg_Twist', 'encode_geometry_msgs_msg_Twist'),
    'geometry_msgs/msg/TwistStamped': ('decode_geometry_msgs_msg_TwistStamped', 'encode_geometry_msgs_msg_TwistStamped'),
    'geometry_msgs/msg/TwistWithCovariance': ('decode_geometry_msgs_msg_TwistWithCovariance', 'encode_geometry_msgs_msg_TwistWithCovariance'),
    'geometry_msgs/msg/TwistWithCovarianceStamped': ('decode_geometry_msgs_msg_TwistWithCovarianceStamped', 'encode_geometry_msgs_msg_TwistWithCovarianceStamped'),
    'geometry_msgs/msg/Vector3': ('decode_geometry_msgs_msg_Vector3', 'encode_geometry_msgs_msg_Vector3'),
    'geometry_msgs/msg/Vector3Stamped': ('decode_geometry_msgs_msg_Vector3Stamped', 'encode_geometry_msgs_msg_Vector3Stamped'),
    'geometry_msgs/msg/VelocityStamped': ('decode_geometry_msgs_msg_VelocityStamped', 'encode_geometry_msgs_msg_VelocityStamped'),
    'geometry_msgs/msg/Wrench': ('decode_geometry_msgs_msg_Wrench', 'encode_geometry_msgs_msg_Wrench'),
    'geometry_msgs/msg/WrenchStamped': ('decode_geometry_msgs_msg_WrenchStamped', 'encode_geometry_msgs_msg_WrenchStamped'),
    'nav_msgs/msg/Goals': ('decode_nav_msgs_msg_Goals', 'encode_nav_msgs_msg_Goals'),
    'nav_msgs/msg/GridCells': ('decode_nav_msgs_msg_GridCells', 'encode_nav_msgs_msg_GridCells'),
    'nav_msgs/msg/MapMetaData': ('decode_nav_msgs_msg_MapMetaData', 'encode_nav_msgs_msg_MapMetaData'),
    'nav_msgs/msg/OccupancyGrid': ('decode_nav_msgs_msg_OccupancyGrid', 'encode_nav_msgs_msg_OccupancyGrid'),
    'nav_msgs/msg/Odometry': ('decode_nav_msgs_msg_Odometry', 'encode_nav_msgs_msg_Odometry'),
    'nav_msgs/msg/Path': ('decode_nav_msgs_msg_Path', 'encode_nav_msgs_msg_Path'),
    'sensor_msgs/msg/BatteryState': ('decode_sensor_msgs_msg_BatteryState', 'encode_sensor_msgs_msg_BatteryState'),
    'sensor_msgs/msg/CameraInfo': ('decode_sensor_msgs_msg_CameraInfo', 'encode_sensor_msgs_msg_CameraInfo'),
    'sensor_msgs/msg/ChannelFloat32': ('decode_sensor_msgs_msg_ChannelFloat32', 'encode_sensor_msgs_msg_ChannelFloat32'),
    'sensor_msgs/msg/CompressedImage': ('decode_sensor_msgs_msg_CompressedImage', 'encode_sensor_msgs_msg_CompressedImage'),
    'sensor_msgs/msg/FluidPressure': ('decode_sensor_msgs_msg_FluidPressure', 'encode_sensor_msgs_msg_FluidPressure'),
    'sensor_msgs/msg/Illuminance': ('decode_sensor_msgs_msg_Illuminance', 'encode_sensor_msgs_msg_Illuminance'),
    'sensor_msgs/msg/Image': ('decode_sensor_msgs_msg_Image', 'encode_sensor_msgs_msg_Image'),
    'sensor_msgs/msg/Imu': ('decode_sensor_msgs_msg_Imu', 'encode_sensor_msgs_msg_Imu'),
    'sensor_msgs/msg/JointState': ('decode_sensor_msgs_msg_JointState', 'encode_sensor_msgs_msg_JointState'),
    'sensor_msgs/msg/Joy': ('decode_sensor_msgs_msg_Joy', 'encode_sensor_msgs_msg_Joy'),
    'sensor_msgs/msg/JoyFeedback': ('decode_sensor_msgs_msg_JoyFeedback', 'encode_sensor_msgs_msg_JoyFeedback'),
    'sensor_msgs/msg/JoyFeedbackArray': ('decode_sensor_msgs_msg_JoyFeedbackArray', 'encode_sensor_msgs_msg_JoyFeedbackArray'),
    'sensor_msgs/msg/LaserEcho': ('decode_sensor_msgs_msg_LaserEcho', 'encode_sensor_msgs_msg_LaserEcho'),
    'sensor_msgs/msg/LaserScan': ('decode_sensor_msgs_msg_LaserScan', 'encode_sensor_msgs_msg_LaserScan'),
    'sensor_msgs/msg/MagneticField': ('decode_sensor_msgs_msg_MagneticField', 'encode_sensor_msgs_msg_MagneticField'),
    'sensor_msgs/msg/MultiDOFJointState': ('decode_sensor_msgs_msg_MultiDOFJointState', 'encode_sensor_msgs_msg_MultiDOFJointState'),
    'sensor_msgs/msg/MultiEchoLaserScan': ('decode_sensor_msgs_msg_MultiEchoLaserScan', 'encode_sensor_msgs_msg_MultiEchoLaserScan'),
    'sensor_msgs/msg/NavSatFix': ('decode_sensor_msgs_msg_NavSatFix', 'encode_sensor_msgs_msg_NavSatFix'),
    'sensor_msgs/msg/NavSatStatus': ('decode_sensor_msgs_msg_NavSatStatus', 'encode_sensor_msgs_msg_NavSatStatus'),
    'sensor_msgs/msg/PointCloud': ('decode_sensor_msgs_msg_PointCloud', 'encode_sensor_msgs_msg_PointCloud'),
    'sensor_msgs/msg/PointCloud2': ('decode_sensor_msgs_msg_PointCloud2', 'encode_sensor_msgs_msg_PointCloud2'),
    'sensor_msgs/msg/PointField': ('decode_sensor_msgs_msg_PointField', 'encode_sensor_msgs_msg_PointField'),
    'sensor_msgs/msg/Range': ('decode_sensor_msgs_msg_Range', 'encode_sensor_msgs_msg_Range'),
    'sensor_msgs/msg/RegionOfInterest': ('decode_sensor_msgs_msg_RegionOfInterest', 'encode_sensor_msgs_msg_RegionOfInterest'),
    'sensor_msgs/msg/RelativeHumidity': ('decode_sensor_msgs_msg_RelativeHumidity', 'encode_sensor_msgs_msg_RelativeHumidity'),
    'sensor_msgs/msg/Temperature': ('decode_sensor_msgs_msg_Temperature', 'encode_sensor_msgs_msg_Temperature'),
    'sensor_msgs/msg/TimeReference': ('decode_sensor_msgs_msg_TimeReference', 'encode_sensor_msgs_msg_TimeReference'),
    'std_msgs/msg/Bool': ('decode_std_msgs_msg_Bool', 'encode_std_msgs_msg_Bool'),
    'std_msgs/msg/Byte': ('decode_std_msgs_msg_Byte', 'encode_std_msgs_msg_Byte'),
    'std_msgs/msg/ByteMultiArray': ('decode_std_msgs_msg_ByteMultiArray', 'encode_std_msgs_msg_ByteMultiArray'),
    'std_msgs/msg/Char': ('decode_std_msgs_msg_Char', 'encode_std_msgs_msg_Char'),
    'std_msgs/msg/ColorRGBA': ('decode_std_msgs_msg_ColorRGBA', 'encode_std_msgs_msg_ColorRGBA'),
    'std_msgs/msg/Empty': ('decode_std_msgs_msg_Empty', 'encode_std_msgs_msg_Empty'),
    'std_msgs/msg/Float32': ('decode_std_msgs_msg_Float32', 'encode_std_msgs_msg_Float32'),
    'std_msgs/msg/Float32MultiArray': ('decode_std_msgs_msg_Float32MultiArray', 'encode_std_msgs_msg_Float32MultiArray'),
    'std_msgs/msg/Float64': ('decode_std_msgs_msg_Float64', 'encode_std_msgs_msg_Float64'),
    'std_msgs/msg/Float64MultiArray': ('decode_std_msgs_msg_Float64MultiArray', 'encode_std_msgs_msg_Float64MultiArray'),
    'std_msgs/msg/Header': ('decode_std_msgs_msg_Header', 'encode_std_msgs_msg_Header'),
    'std_msgs/msg/Int16': ('decode_std_msgs_msg_Int16', 'encode_std_msgs_msg_Int16'),
    'std_msgs/msg/Int16MultiArray': ('decode_std_msgs_msg_Int16MultiArray', 'encode_std_msgs_msg_Int16MultiArray'),
    'std_msgs/msg/Int32': ('decode_std_msgs_msg_Int32', 'encode_std_msgs_msg_Int32'),
    'std_msgs/msg/Int32MultiArray': ('decode_std_msgs_msg_Int32MultiArray', 'encode_std_msgs_msg_Int32MultiArray'),
    'std_msgs/msg/Int64': ('decode_std_msgs_msg_Int64', 'encode_std_msgs_msg_Int64'),
    'std_msgs/msg/Int64MultiArray': ('decode_std_msgs_msg_Int64MultiArray', 'encode_std_msgs_msg_Int64MultiArray'),
    'std_msgs/msg/Int8': ('decode_std_msgs_msg_Int8', 'encode_std_msgs_msg_Int8'),
    'std_msgs/msg/Int8MultiArray': ('decode_std_msgs_msg_Int8MultiArray', 'encode_std_msgs_msg_Int8MultiArray'),
    'std_msgs/msg/MultiArrayDimension': ('decode_std_msgs_msg_MultiArrayDimension', 'encode_std_msgs_msg_MultiArrayDimension'),
    'std_msgs/msg/MultiArrayLayout': ('decode_std_msgs_msg_MultiArrayLayout', 'encode_std_msgs_msg_MultiArrayLayout'),
    'std_msgs/msg/String': ('decode_std_msgs_msg_String', 'encode_std_msgs_msg_String'),
    'std_msgs/msg/UInt16': ('decode_std_msgs_msg_UInt16', 'encode_std_msgs_msg_UInt16'),
    'std_msgs/msg/UInt16MultiArray': ('decode_std_msgs_msg_UInt16MultiArray', 'encode_std_msgs_msg_UInt16MultiArray'),
    'std_msgs/msg/UInt32': ('decode_std_msgs_msg_UInt32', 'encode_std_msgs_msg_UInt32'),
    'std_msgs/msg/UInt32MultiArray': ('decode_std_msgs_msg_UInt32MultiArray', 'encode_std_msgs_msg_UInt32MultiArray'),
    'std_msgs/msg/UInt64': ('decode_std_msgs_msg_UInt64', 'encode_std_msgs_msg_UInt64'),
    'std_msgs/msg/UInt64MultiArray': ('decode_std_msgs_msg_UInt64MultiArray', 'encode_std_msgs_msg_UInt64MultiArray'),
    'std_msgs/msg/UInt8': ('decode_std_msgs_msg_UInt8', 'encode_std_msgs_msg_UInt8'),
    'std_msgs/msg/UInt8MultiArray': ('decode_std_msgs_msg_UInt8MultiArray', 'encode_std_msgs_msg_UInt8MultiArray'),
}

def get_decoder(msg_name: str) -> Callable[[Any], type] | None:
    """Get pre-compiled decoder function for a message type."""
    if msg_name in MESSAGE_REGISTRY:
        func_name = MESSAGE_REGISTRY[msg_name][0]
        return globals()[func_name]
    return None

def get_encoder(msg_name: str) -> Callable[[Any, Any], None] | None:
    """Get pre-compiled encoder function for a message type."""
    if msg_name in MESSAGE_REGISTRY:
        func_name = MESSAGE_REGISTRY[msg_name][1]
        return globals()[func_name]
    return None

def initialize_dataclass_types() -> None:
    """Initialize dataclass types from the message definitions."""
    from pybag.ros2.humble import (
        builtin_interfaces,
        geometry_msgs,
        nav_msgs,
        sensor_msgs,
        std_msgs,
    )
    
    # Map sanitized names to actual dataclass types
    modules = [builtin_interfaces, geometry_msgs, nav_msgs, sensor_msgs, std_msgs]
    
    for module in modules:
        for name in dir(module):
            obj = getattr(module, name)
            if hasattr(obj, "__msg_name__"):
                # Sanitize the message name to match the dataclass type name
                sanitized = obj.__msg_name__.replace("/", "_").replace("::", "_")
                _dataclass_types[sanitized] = obj
